import * as fs from "node:fs/promises";
import * as path from "node:path";
import crypto from "node:crypto";

export type Trip = {
  id: string;
  name: string;
  createdAt: string;
  updatedAt: string;
};

export type Conversation = {
  id: string;
  tripId: string;
  title: string;
  createdAt: string;
  updatedAt: string;
  sessionKey?: string | null;
  /** "user" if manually renamed, "auto" if generated by AI */
  titleSource?: "user" | "auto";
  /** ISO timestamp of last title update */
  titleUpdatedAt?: string;
};

export type StoredMessage = {
  id: string;
  type: "user" | "assistant" | "system";
  content: string;
  timestamp: string;
  metadata?: Record<string, unknown>;
};

type CreateConversationInput = {
  title?: string | null;
  initialAssistantMessage?: string | null;
  sessionKey?: string | null;
};

export function defaultSessionKey(tripId: string, conversationId: string): string {
  return `agent:travel:${tripId}:${conversationId}`;
}

function nowIso(): string {
  return new Date().toISOString();
}

export function createStorage(root: string) {
  const tripsRoot = () => path.join(root, "trips");
  const tripDir = (tripId: string) => path.join(tripsRoot(), tripId);
  const tripMetaPath = (tripId: string) => path.join(tripDir(tripId), "trip.json");
  const itineraryPath = (tripId: string) => path.join(tripDir(tripId), "itinerary.md");
  const contextPath = (tripId: string) => path.join(tripDir(tripId), "context.md");
  const conversationsRoot = (tripId: string) => path.join(tripDir(tripId), "chats");
  const conversationDir = (tripId: string, conversationId: string) =>
    path.join(conversationsRoot(tripId), conversationId);
  const conversationMetaPath = (tripId: string, conversationId: string) =>
    path.join(conversationDir(tripId, conversationId), "conversation.json");
  const messagesPath = (tripId: string, conversationId: string) =>
    path.join(conversationDir(tripId, conversationId), "messages.jsonl");

  async function ensureDataDirs(): Promise<void> {
    await fs.mkdir(tripsRoot(), { recursive: true });
  }

  async function readJsonFile<T>(filePath: string): Promise<T | null> {
    try {
      const raw = await fs.readFile(filePath, "utf8");
      return JSON.parse(raw) as T;
    } catch (err: any) {
      if (err?.code === "ENOENT") return null;
      throw err;
    }
  }

  async function writeFileAtomic(filePath: string, content: string): Promise<void> {
    const dir = path.dirname(filePath);
    await fs.mkdir(dir, { recursive: true });
    const tmp = path.join(dir, `${path.basename(filePath)}.${Date.now()}.tmp`);
    await fs.writeFile(tmp, content, "utf8");
    await fs.rename(tmp, filePath);
  }

  async function listTrips(): Promise<Trip[]> {
    await ensureDataDirs();
    const rootDir = tripsRoot();
    const entries = await fs.readdir(rootDir, { withFileTypes: true });
    const trips: Trip[] = [];
    for (const ent of entries) {
      if (!ent.isDirectory()) continue;
      const meta = await readJsonFile<Trip>(tripMetaPath(ent.name));
      if (meta) trips.push(meta);
    }
    trips.sort((a, b) => b.updatedAt.localeCompare(a.updatedAt));
    return trips;
  }

  async function createTrip(name: string): Promise<Trip> {
    await ensureDataDirs();
    const id = crypto.randomUUID();
    const dir = tripDir(id);
    await fs.mkdir(dir, { recursive: true });
    await fs.mkdir(conversationsRoot(id), { recursive: true });

    const t = nowIso();
    const tripName = name.trim() || "Untitled trip";
    const trip: Trip = { id, name: tripName, createdAt: t, updatedAt: t };
    await writeFileAtomic(tripMetaPath(id), JSON.stringify(trip, null, 2));
    await ensureItinerary(id, tripName);
    await ensureContext(id);
    return trip;
  }

  async function getTrip(tripId: string): Promise<Trip | null> {
    return readJsonFile<Trip>(tripMetaPath(tripId));
  }

  async function updateTrip(tripId: string, patch: Partial<Trip>): Promise<Trip | null> {
    const current = await getTrip(tripId);
    if (!current) return null;
    const next: Trip = {
      ...current,
      ...patch,
      id: current.id,
      updatedAt: nowIso(),
    };
    await writeFileAtomic(tripMetaPath(tripId), JSON.stringify(next, null, 2));
    return next;
  }

  async function touchTrip(tripId: string): Promise<void> {
    const trip = await getTrip(tripId);
    if (!trip) return;
    trip.updatedAt = nowIso();
    await writeFileAtomic(tripMetaPath(tripId), JSON.stringify(trip, null, 2));
  }

  async function deleteTrip(tripId: string): Promise<boolean> {
    const rootDir = tripsRoot();
    const resolved = path.join(rootDir, tripId);
    try {
      await fs.access(resolved);
    } catch (err: any) {
      if (err?.code === "ENOENT") return false;
      throw err;
    }
    await fs.rm(resolved, { recursive: true, force: true });
    return true;
  }

  async function ensureItinerary(tripId: string, tripName?: string): Promise<void> {
    try {
      await fs.access(itineraryPath(tripId));
    } catch (err: any) {
      if (err?.code !== "ENOENT") throw err;
      let name = tripName;
      if (!name) {
        const trip = await getTrip(tripId);
        name = trip?.name ?? "My Trip";
      }
      const template = [
        `# ${name} — Itinerary`,
        ``,
        `## Overview`,
        ``,
        `- Dates: TBD`,
        `- Travelers: TBD`,
        `- Pace: TBD`,
        ``,
        `## Destinations`,
        ``,
        `<details open>`,
        `<summary><strong>Day 1 — Arrival</strong></summary>`,
        ``,
        `- [ ] Book flights`,
        `- [ ] Book first night lodging`,
        ``,
        `</details>`,
        ``,
      ].join("\n");
      await writeFileAtomic(itineraryPath(tripId), template);
    }
  }

  async function readItinerary(tripId: string): Promise<string> {
    try {
      return await fs.readFile(itineraryPath(tripId), "utf8");
    } catch (err: any) {
      if (err?.code === "ENOENT") return "";
      throw err;
    }
  }

  async function writeItinerary(tripId: string, content: string): Promise<void> {
    await writeFileAtomic(itineraryPath(tripId), content);
    await touchTrip(tripId);
  }

  async function toggleTodoAtLine(
    tripId: string,
    line1Based: number
  ): Promise<{ updated: boolean; content: string }> {
    const content = await readItinerary(tripId);
    const lines = content.split("\n");
    const idx = line1Based - 1;
    if (idx < 0 || idx >= lines.length) return { updated: false, content };
    const line = lines[idx];
    const unchecked = /^(\s*)([-*+]|\d+\.)\s+\[ \]/;
    const checked = /^(\s*)([-*+]|\d+\.)\s+\[[xX]\]/;
    if (unchecked.test(line)) lines[idx] = line.replace(unchecked, "$1$2 [x]");
    else if (checked.test(line)) lines[idx] = line.replace(checked, "$1$2 [ ]");
    else return { updated: false, content };
    const next = lines.join("\n");
    await writeItinerary(tripId, next);
    return { updated: true, content: next };
  }

  async function ensureContext(tripId: string): Promise<void> {
    try {
      await fs.access(contextPath(tripId));
    } catch (err: any) {
      if (err?.code !== "ENOENT") throw err;
      const template = [
        "# Trip Context",
        "",
        "## Trip Details",
        "- Dates: TBD",
        "- Travelers: TBD",
        "",
        "## Confirmed Bookings",
        "- None yet",
        "",
        "## Preferences",
        "- Pace: TBD",
        "- Interests: TBD",
        "- Dietary: TBD",
        "",
        "## Pending Decisions",
        "- None yet",
        "",
        "## Last Updated",
        nowIso(),
        "",
      ].join("\n");
      await writeFileAtomic(contextPath(tripId), template);
    }
  }

  async function readContext(tripId: string): Promise<string> {
    await ensureContext(tripId);
    try {
      return await fs.readFile(contextPath(tripId), "utf8");
    } catch (err: any) {
      if (err?.code === "ENOENT") return "";
      throw err;
    }
  }

  async function writeContext(tripId: string, content: string): Promise<void> {
    await writeFileAtomic(contextPath(tripId), content);
    await touchTrip(tripId);
  }

  async function listConversations(tripId: string): Promise<Conversation[]> {
    await fs.mkdir(conversationsRoot(tripId), { recursive: true });
    const entries = await fs.readdir(conversationsRoot(tripId), { withFileTypes: true });
    const conversations: Conversation[] = [];
    for (const ent of entries) {
      if (!ent.isDirectory()) continue;
      const meta = await readJsonFile<Conversation>(conversationMetaPath(tripId, ent.name));
      if (meta) conversations.push(meta);
    }
    conversations.sort((a, b) => b.updatedAt.localeCompare(a.updatedAt));
    return conversations;
  }

  async function createConversation(tripId: string, input: CreateConversationInput = {}): Promise<Conversation> {
    await fs.mkdir(conversationsRoot(tripId), { recursive: true });
    const id = crypto.randomUUID();
    const dir = conversationDir(tripId, id);
    await fs.mkdir(dir, { recursive: true });
    const t = nowIso();
    const meta: Conversation = {
      id,
      tripId,
      title: input.title?.trim() || "Conversation",
      createdAt: t,
      updatedAt: t,
      sessionKey: input.sessionKey ?? defaultSessionKey(tripId, id),
    };
    await writeFileAtomic(conversationMetaPath(tripId, id), JSON.stringify(meta, null, 2));
    await fs.writeFile(messagesPath(tripId, id), "", "utf8");
    if (input.initialAssistantMessage) {
      await appendMessage(tripId, id, {
        id: crypto.randomUUID(),
        type: "assistant",
        content: input.initialAssistantMessage,
        timestamp: nowIso(),
      });
    }
    await touchTrip(tripId);
    return meta;
  }

  async function getConversation(tripId: string, conversationId: string): Promise<Conversation | null> {
    return readJsonFile<Conversation>(conversationMetaPath(tripId, conversationId));
  }

  async function updateConversation(tripId: string, conversationId: string, patch: Partial<Conversation>): Promise<void> {
    const current = (await getConversation(tripId, conversationId)) ?? {
      id: conversationId,
      tripId,
      title: "Conversation",
      createdAt: nowIso(),
      updatedAt: nowIso(),
    };
    const next: Conversation = {
      ...current,
      ...patch,
      id: current.id,
      tripId: current.tripId,
      updatedAt: nowIso(),
    };
    await writeFileAtomic(conversationMetaPath(tripId, conversationId), JSON.stringify(next, null, 2));
    await touchTrip(tripId);
  }

  async function appendMessage(tripId: string, conversationId: string, msg: StoredMessage): Promise<void> {
    await fs.mkdir(conversationDir(tripId, conversationId), { recursive: true });
    await fs.appendFile(messagesPath(tripId, conversationId), JSON.stringify(msg) + "\n", "utf8");
    await updateConversation(tripId, conversationId, {});
  }

  async function readMessages(tripId: string, conversationId: string, limit = 500): Promise<StoredMessage[]> {
    try {
      const raw = await fs.readFile(messagesPath(tripId, conversationId), "utf8");
      const lines = raw.split("\n").filter(Boolean);
      const parsed: StoredMessage[] = [];
      for (const line of lines) {
        try {
          const entry = JSON.parse(line) as StoredMessage;
          if (entry && entry.type && entry.content) parsed.push(entry);
        } catch {
          continue;
        }
      }
      if (parsed.length <= limit) return parsed;
      return parsed.slice(-limit);
    } catch (err: any) {
      if (err?.code === "ENOENT") return [];
      throw err;
    }
  }

  async function deleteConversation(tripId: string, conversationId: string): Promise<boolean> {
    const rootDir = conversationsRoot(tripId);
    const resolved = path.join(rootDir, conversationId);
    try {
      await fs.access(resolved);
    } catch (err: any) {
      if (err?.code === "ENOENT") return false;
      throw err;
    }
    await fs.rm(resolved, { recursive: true, force: true });
    await touchTrip(tripId);
    return true;
  }

  return {
    listTrips,
    createTrip,
    getTrip,
    updateTrip,
    deleteTrip,
    ensureItinerary,
    readItinerary,
    writeItinerary,
    toggleTodoAtLine,
    ensureContext,
    readContext,
    writeContext,
    listConversations,
    createConversation,
    getConversation,
    updateConversation,
    appendMessage,
    readMessages,
    deleteConversation,
  };
}
